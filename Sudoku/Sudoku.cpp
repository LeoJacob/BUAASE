// Sudoku.cpp: 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include <cstdlib>
#include <string>
#include <ctime>
#include "Core.h"

bool notIn(char c, char *str)
{
    while (*str)
    {
        if (c == *str)
            return false;
        str++;
    }
    return true;
}

int c2mask(char c)
{
    int res = 1;
    switch (c)
    {
    case 'c':
        res <<= 1;
    case 's':
        res <<= 1;
    case 'n':
        res <<= 1;
    case 'm':
        res <<= 1;
    case 'r':
        res <<= 1;
    case 'u':
        break;
    default:
        res = -1;
    }
    return res;
}

bool isnumber(char *str)
{
    int i;
    for (i = 0; str[i]; i += 1)
    {
        if (!isdigit(str[i]))
            return false;
    }
    return true;
}

bool s2n(int &number, char *str, int maximum)
{
    int i;
    number = 0;
    for(i = 0;str[i];i += 1)
    {
        number = number * 10 + str[i] - '0';
        if (number > maximum)
            return false;
    }
    return true;
}

void usage()
{ 
    printf(
"Usage: sudoku [option]\n"
"  -c <number>  Generate <number> sudoku end and output them to sudoku.txt.\n"
"               <number> should be a integer and in [1, 1000000].\n"
"               Note: The option should be used without any other options.\n"
"\n"
"  -s <path>    Solve sudoku puzzle contained in <path> and output their solution"
"               to sudoku.txt.\n"
"               Note: The option should be used without any other options.\n"
"\n"
"  -n <number>  Generate <number> sudoku puzzles and output them to sudoku.txt.\n"
"               The option can be used with option -m, -r or -u.\n"
"\n"
"  -m <mode>    Indicate the difficulty of sudoku puzzles generated by -n.\n"
"               <mode> should be a integer and in {1, 2, 3}.\n"
"               Note: The option must be used with option -n, and not used with\n"
"                   option -r or -u.\n"
"\n"
"  -r <lower>~<upper>\n"
"               Indicate the number of blanks of sudoku puzzles generated\n"
"               by -n. <lower> and <upper> should be a integer and in [20, 55].\n"
"               <lower> should be less than or equal to <upper>.\n"
"               Note: The option must be used with option -n, and not used with\n"
"                   option -m.\n"
"\n"
"  -u           Indicate whether the sudoku puzzles generated by -n have unique\n"
"               solutions.\n"
"               Note: The option must be used with option -n, and not used with\n"
"                   option -m.\n"
    );
}

void handleParameter(int argc, char *argv[])
{
    int i;
    int mask = 0, r, cur, pos;
    int len;
    int number = 0, mode = 1, lowerBlank = 0, upperBlank = 0;
    std::string path;
    bool unique = false;
    for (cur = 1; cur < argc; cur += 1)
    {
        len = strlen(argv[cur]);
        if (len != 2 || argv[cur][0] != '-'
            || notIn(argv[cur][1], "csnmru"))
            throw std::invalid_argument("Unknown parameter " + std::string(argv[cur]));
        r = c2mask(argv[cur][1]);
        if (mask & r)
            throw std::invalid_argument("Duplicate parmeter " + std::string(argv[cur]));
        mask |= r;
        switch (argv[cur][1])
        {
        case 'c':
            if(cur + 1 >= argc)
                throw std::invalid_argument("Parmeter -c should be followed a integer in [1, 1000000]");
            cur += 1;
            if(!isnumber(argv[cur]))
                throw std::invalid_argument("Parmeter -c should be followed a integer in [1, 1000000]");
            if(!s2n(number, argv[cur], 1000000)
                || !(1 <= number && number <= 1000000))
                throw std::invalid_argument("The integar of -c should be in [1, 1000000]");
            break;
        case 's':
            if(cur + 1 >= argc)
                throw std::invalid_argument("Parmeter -s should be followed a path");
            path = std::string(argv[++cur]);
            break;
        case 'n':
            if(cur + 1 >= argc)
                throw std::invalid_argument("Parmeter -n should be followed a integer in [1, 10000]");
            cur += 1;
            if(!isnumber(argv[cur]))
                throw std::invalid_argument("Parmeter -n should be followed a integer in [1, 10000]");
            if(!s2n(number, argv[cur], 10000)
                || !(1 <= number && number <= 10000))
                throw std::invalid_argument("The integar of -n should be in [1, 10000]");
            break;
        case 'm':
            if(cur + 1 >= argc)
                throw std::invalid_argument("Parmeter -m should be followed a integer in {1, 2, 3}");
            cur += 1;
            if(!isnumber(argv[cur]))
                throw std::invalid_argument("Parmeter -m should be followed a integer in {1, 2, 3}");
            if(!s2n(mode, argv[cur], 3)
                || !(1 <= mode && mode <= 3))
                throw std::invalid_argument("The integar of -m should be in {1, 2, 3}");
            break;
        case 'r':
            if(cur + 1 >= argc)
                throw std::invalid_argument("Parmeter -r should be followed a string in the form of <integer>~<integer>");
            cur += 1;
            for (i = 0, pos = -1; argv[cur][i]; i += 1)
            {
                if (argv[cur][i] == '~')
                {
                    if (pos < 0)
                        pos = i;
                    else
                        throw std::invalid_argument("Parmeter -r should be followed a string in the form of <integer>~<integer>");
                }
            }
            if(pos < 0 || !pos || !argv[cur][pos + 1])
                throw std::invalid_argument("Parmeter -r should be followed a string in the form of <integer>~<integer>");
            argv[cur][pos] = '\0';
            if(!isnumber(argv[cur]) || !isnumber(argv[cur] + pos + 1))
                throw std::invalid_argument("Parmeter -r should be followed a string in the form of <integer>~<integer>");
            if(!s2n(lowerBlank, argv[cur], 55)
                || !(20 <= lowerBlank && lowerBlank <= 55)
                || !s2n(upperBlank, argv[cur] + pos + 1, 55)
                || !(20 <= upperBlank && upperBlank <= 55))
                throw std::invalid_argument("Parmeter -r's two integer should be both in [20, 55]");
            if(!(lowerBlank <= upperBlank))
                throw std::invalid_argument("The first integer of parmeter -r should be less than or equal to the second");
            break;
        case 'u':
            unique = true;
            break;
        }
    }
    if(!(mask & c2mask('c')) && !(mask & c2mask('s')) && !(mask & c2mask('n')))
        throw std::invalid_argument("There should be one parameter of -c, -s, -n");
    if (((mask & c2mask('c')) && (mask ^ c2mask('c')))
        || ((mask & c2mask('s')) && (mask ^ c2mask('s'))))
        throw std::invalid_argument("Parameter -c (or -s) should be used alone");
    if(((mask & c2mask('m')) && (mask & c2mask('r')))
        || ((mask & c2mask('m')) && (mask & c2mask('u'))))
        throw std::invalid_argument("Parameter -m and -r/-u cannot be used together");
    if (mask & c2mask('c'))
    {
        Core core;
        int(*result)[81] = new int[number][81];
        core.generate(number, 0, 0, true, result);
        int i, j, k;
        FILE *fout;
        fout = fopen("sudoku.txt", "w");
        for (i = 0; i < number; i += 1)
        {
            for (j = 0; j < 9; j += 1)
            {
                for (k = 0; k < 9; k += 1)
                    fprintf(fout, "%d%c", result[i][j * 9 + k], " \n"[k + 1 == 9?1:0]);
            }
            if(i + 1 < number)
                fprintf(fout, "\n");
        }
        fclose(fout);
        delete [] result;
    }
    else if (mask & c2mask('s'))
    {
		int i, j;
		int cnt = 0;
		Sudoku9DLXSolver solver;
		Sudoku9 puzzle, ans;
		char buffer[1000] = {};
		FILE *fout;
		if (!freopen(path.c_str(), "r", stdin))
			throw std::invalid_argument("Cannot open " + path);
		fout = fopen("sudoku.txt", "w");
		while (1)
		{
			for (i = 0; i < 9; i += 1)
			{
				for (j = 0; j < 9; j += 1)
				{
                    if (scanf("%s", buffer) == EOF)
                        break;
                    if (!isnumber(buffer)
                        || !s2n(puzzle.data[i][j], buffer, 9))
                        throw std::runtime_error("The puzzle file is malformed!");
				}
				if (j < 9)
					break;
			}
            if (!i && !j)
                break;
			if (i < 9)
                throw std::runtime_error("The puzzle file is malformed!");
			if (cnt)
				fputc('\n', fout);
			solver.set(puzzle);
			if (solver.solve())
			{
				ans = solver.solution();
				for (i = 0; i < 9; i += 1)
				{
					for (j = 0; j < 9; j += 1)
					{
						buffer[(i * 9 + j) * 2] = ans.data[i][j] + '0';
						buffer[(i * 9 + j) * 2 + 1] = " \n"[j + 1 == 9 ? 1 : 0];
					}
				}
				fwrite(buffer, 1, 162, fout);
			}
			else
				fprintf(fout, "No Solution!\n");
			cnt += 1;
		}
		fclose(fout);
    }
    else
    {
        Core core;
        int(*result)[81] = new int[number][81];
        if (mask & c2mask('r'))
            core.generate(number, lowerBlank, upperBlank, unique, result);
        else
            core.generate(number, mode, result);

        int i, j, k;
        FILE *fout;
        fout = fopen("sudoku.txt", "w");
        for (i = 0; i < number; i += 1)
        {
            for (j = 0; j < 9; j += 1)
            {
                for (k = 0; k < 9; k += 1)
                    fprintf(fout, "%d%c", result[i][j * 9 + k], " \n"[k + 1 == 9?1:0]);
            }
            if (i + 1 < number)
                fprintf(fout, "\n");
        }
        fclose(fout);
    }
}

int main(int argc, char *argv[])
{
    srand(time(0));
    try {
        handleParameter(argc, argv);
    }
    catch (std::exception e)
    {
        printf("%s\n", e.what());
        usage();
    }
}

